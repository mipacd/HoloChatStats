<!DOCTYPE html>
<html lang="{{ get_locale() }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Hololive and Indie monthly streaming hours over time.">
    <meta name="keywords" content="HoloChatStats, Hololive, VTuber, Indie, chat statistics, monthly streaming hours">
    <title>{{ _("Monthly Streaming Hours") }}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
    <style>
        html, body {
           overflow-x: hidden;
       }
        .form-group {
            margin-bottom: 15px;
        }
        .chart-container {
            margin-top: 10px;
            position: relative;
            height: 70vh;
            max-width: 98vw;
            overflow-x: auto;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
        }
        /* === Sticky Eri Widget === */
        .eri-widget {
            position: fixed;
            bottom: 20px;
            right: 25px;
            z-index: 9999;
            display: flex;
            align-items: flex-end;
            gap: 10px;
            cursor: pointer;
        }

        .eri-bubble {
            background: rgba(255, 255, 255, 0.95);
            color: #222;
            padding: 10px 14px;
            border-radius: 14px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            font-size: 0.95rem;
            line-height: 1.3;
            position: relative;
            transition: all 0.3s ease;
        }

        .eri-bubble::after {
            content: "";
            position: absolute;
            bottom: 12px;
            right: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: transparent transparent transparent rgba(255, 255, 255, 0.95);
        }

        .eri-bubble:hover {
            transform: scale(1.03);
        }

        .eri-chibi {
            width: 50px;
            height: auto;
            transition: transform 0.3s ease;
        }

        .eri-chibi:hover {
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .eri-widget {
                bottom: 10px;
                right: 10px;
                flex-direction: column;
                align-items: flex-end;
            }

            .eri-chibi {
                width: 80px;
            }

            .eri-bubble {
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>

{% include 'menu.html' %}

<!-- Main Content -->
<div id="content" class="mt-3">
    <h2 class="text-center mb-4">{{ _("Monthly Streaming Hours") }}
        <sup><i class="bi bi-info-circle" data-bs-toggle="tooltip" data-bs-placement="top" 
        title="{{ _("Only counts public archived streams from YouTube.") }}"></i></sup>
    </h2>
    
    <div class="row mb-3">
        <div class="col-md-6">
            <label for="channelSelect">{{ _("Channel:") }}</label>
            <select id="channelSelect" class="form-select">
                <option value="">{{ _("Select Channel") }}</option>
            </select>
        </div>
    </div>

    <div class="chart-container">
        <div class="position-absolute top-0 end-0 m-3 d-flex gap-2">
        <button id="downloadPNG" class="btn btn-sm btn-primary">
            <i class="fas fa-image"></i> {{ _("Download PNG") }}
        </button>
    </div>
        <div id="chartSpinner" class="spinner-border text-primary position-absolute top-50 start-50" role="status" style="display: none;">
            <span class="visually-hidden">Loading...</span>
        </div>
        <canvas id="streamingChart"></canvas>
    </div>
</div>
{% include 'eri_widget.html' %}

<script>
    $(document).ready(function() {
        // Initialize Chart.js for line chart
        let ctx = document.getElementById('streamingChart').getContext('2d');
        let chart = new Chart(ctx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.raw;
                                const dataIndex = context.dataIndex;
                                
                                // Skip null values and confidence band datasets
                                if (value === null || 
                                    label === '{{ _("Confidence Band") }}' || 
                                    label === 'confidenceHigh') {
                                    return null;
                                }
                                
                                // For forecast dataset, check if this is the connection point
                                if (label === '{{ _("Forecast") }}') {
                                    // Check if historical data exists at this index
                                    const historicalDataset = context.chart.data.datasets.find(
                                        ds => ds.label === '{{ _("Streaming Hours") }}'
                                    );
                                    
                                    if (historicalDataset && historicalDataset.data[dataIndex] !== null) {
                                        // This is the connection point - don't show forecast tooltip
                                        return null;
                                    }
                                    
                                    // This is a true forecast point
                                    const datasets = context.chart.data.datasets;
                                    const lowDataset = datasets.find(ds => ds.label === '{{ _("Confidence Band") }}');
                                    const highDataset = datasets.find(ds => ds.label === 'confidenceHigh');
                                    
                                    let lines = [`{{ _("Forecast") }}: ${value.toFixed(2)} hours`];
                                    
                                    if (lowDataset && highDataset) {
                                        const low = lowDataset.data[dataIndex];
                                        const high = highDataset.data[dataIndex];
                                        if (low !== null && high !== null) {
                                            lines.push(`{{ _("P25-P75 Range") }}: ${low.toFixed(2)} - ${high.toFixed(2)} hours`);
                                        }
                                    }
                                    
                                    return lines;
                                }
                                
                                // Handle historical points
                                if (label === '{{ _("Streaming Hours") }}') {
                                    return `{{ _("Streaming Hours") }}: ${value.toFixed(2)} hours`;
                                }
                                
                                return null;
                            },
                            filter: function(tooltipItem) {
                                const label = tooltipItem.dataset.label;
                                const value = tooltipItem.raw;
                                const dataIndex = tooltipItem.dataIndex;
                                
                                // Always filter out null values and confidence bands
                                if (value === null || 
                                    label === '{{ _("Confidence Band") }}' || 
                                    label === 'confidenceHigh') {
                                    return false;
                                }
                                
                                // For forecast, filter out the connection point
                                if (label === '{{ _("Forecast") }}') {
                                    const historicalDataset = tooltipItem.chart.data.datasets.find(
                                        ds => ds.label === '{{ _("Streaming Hours") }}'
                                    );
                                    
                                    if (historicalDataset && historicalDataset.data[dataIndex] !== null) {
                                        return false; // This is the connection point
                                    }
                                }
                                
                                return true;
                            }
                        }
                    },
                    legend: {
                        labels: {
                            color: "white",
                            filter: function(legendItem, chartData) {
                                return legendItem.text !== 'confidenceHigh' && 
                                       legendItem.text !== '{{ _("Confidence Band") }}';
                            }
                        }
                    },
                    filler: {
                        propagate: false
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: '{{ _("Month") }}', color: "white" },
                        ticks: { color: "white" }
                    },
                    y: {
                        title: { display: true, text: '{{ _("Streaming Hours") }}', color: "white" },
                        ticks: { color: "white" },
                        beginAtZero: true
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });

        // Fetch channel names
        function fetchChannels() {
            let url = '/api/get_channel_names';
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    let channelSelect = document.getElementById('channelSelect');
                    data.forEach(channel => {
                        let option = document.createElement('option');
                        option.value = channel;
                        option.text = channel;
                        channelSelect.appendChild(option);
                    });
                })
                .catch(error => console.error("Error fetching channel names:", error));
        }

        // Helper function to parse YYYY-MM to a comparable value
        function monthToNumber(monthStr) {
            const [year, month] = monthStr.split('-').map(Number);
            return year * 12 + month;
        }

        // Helper function to convert number back to YYYY-MM
        function numberToMonth(num) {
            const year = Math.floor((num - 1) / 12);
            const month = ((num - 1) % 12) + 1;
            return `${year}-${String(month).padStart(2, '0')}`;
        }

        // Fetch data and update chart
        function fetchData() {
            let channelName = document.getElementById('channelSelect').value;
            if (!channelName) {
                $("#chartSpinner").hide();
                alert('{{ _("Please select a channel.") }}');
                return;
            }

            let url = `/api/get_monthly_streaming_hours?channel=${encodeURIComponent(channelName)}`;
            
            $("#chartSpinner").show();

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (!data || data.length === 0) {
                        console.error("No data available for the selected channel.");
                        $("#chartSpinner").hide();
                        return;
                    }

                    // Separate historical and forecast data
                    const historicalData = data.filter(d => !d.is_forecast);
                    const forecastData = data.filter(d => d.is_forecast);

                    console.log('Historical data:', historicalData.length, 'months');
                    console.log('Forecast data:', forecastData.length, 'months');
                    console.log('Forecast months:', forecastData.map(d => d.month));

                    // Helper function to fill in missing months
                    function fillMissingMonths(historicalData, forecastData) {
                        if (historicalData.length === 0) {
                            return { 
                                labels: [], 
                                historicalValues: [], 
                                forecastValues: [],
                                confidenceLow: [],
                                confidenceHigh: []
                            };
                        }
                        
                        // Create maps for quick lookup
                        const historicalMap = new Map(
                            historicalData.map(d => [d.month, d.total_streaming_hours])
                        );
                        const forecastMap = new Map(
                            forecastData.map(d => [d.month, {
                                value: d.total_streaming_hours,
                                low: d.confidence_low,
                                high: d.confidence_high
                            }])
                        );
                        
                        // Get all months from both datasets
                        const allMonths = [
                            ...historicalData.map(d => d.month),
                            ...forecastData.map(d => d.month)
                        ];
                        
                        // Convert to numbers for reliable comparison
                        const monthNumbers = allMonths.map(monthToNumber);
                        const minMonthNum = Math.min(...monthNumbers);
                        const maxMonthNum = Math.max(...monthNumbers);
                        
                        console.log('Month range:', numberToMonth(minMonthNum), 'to', numberToMonth(maxMonthNum));
                        
                        const labels = [];
                        const historicalValues = [];
                        const forecastValues = [];
                        const confidenceLow = [];
                        const confidenceHigh = [];
                        
                        let lastHistoricalValue = null;
                        let lastHistoricalIndex = -1;
                        
                        // Iterate through all months using simple number comparison
                        for (let monthNum = minMonthNum; monthNum <= maxMonthNum; monthNum++) {
                            const monthStr = numberToMonth(monthNum);
                            labels.push(monthStr);
                            
                            const historicalValue = historicalMap.get(monthStr);
                            const forecastEntry = forecastMap.get(monthStr);
                            
                            if (historicalValue !== undefined) {
                                // Historical data point
                                historicalValues.push(historicalValue);
                                forecastValues.push(null);
                                confidenceLow.push(null);
                                confidenceHigh.push(null);
                                lastHistoricalValue = historicalValue;
                                lastHistoricalIndex = labels.length - 1;
                            } else if (forecastEntry) {
                                // Forecast data point
                                historicalValues.push(null);
                                forecastValues.push(forecastEntry.value);
                                confidenceLow.push(forecastEntry.low);
                                confidenceHigh.push(forecastEntry.high);
                            } else {
                                // Missing month in historical range - fill with 0
                                historicalValues.push(0);
                                forecastValues.push(null);
                                confidenceLow.push(null);
                                confidenceHigh.push(null);
                                lastHistoricalValue = 0;
                                lastHistoricalIndex = labels.length - 1;
                            }
                        }
                        
                        // Connect the last historical point to forecast line
                        if (lastHistoricalIndex >= 0 && forecastData.length > 0 && lastHistoricalValue !== null) {
                            forecastValues[lastHistoricalIndex] = lastHistoricalValue;
                            confidenceLow[lastHistoricalIndex] = lastHistoricalValue;
                            confidenceHigh[lastHistoricalIndex] = lastHistoricalValue;
                        }
                        
                        console.log('Processed labels:', labels);
                        console.log('Forecast values:', forecastValues);
                        
                        return { 
                            labels, 
                            historicalValues, 
                            forecastValues,
                            confidenceLow,
                            confidenceHigh
                        };
                    }

                    // Process the data
                    const processed = fillMissingMonths(historicalData, forecastData);

                    // Build datasets array
                    const datasets = [
                        {
                            label: '{{ _("Streaming Hours") }}',
                            data: processed.historicalValues,
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            spanGaps: false,
                            order: 2
                        }
                    ];

                    // Add forecast datasets if there's forecast data
                    if (forecastData.length > 0) {
                        // Confidence band lower bound
                        datasets.push({
                            label: '{{ _("Confidence Band") }}',
                            data: processed.confidenceLow,
                            backgroundColor: 'transparent',
                            borderColor: 'rgba(255, 206, 86, 0.3)',
                            borderWidth: 1,
                            borderDash: [3, 3],
                            pointRadius: 0,
                            fill: false,
                            spanGaps: true,
                            order: 4
                        });

                        // Confidence band upper bound (fills to lower bound)
                        datasets.push({
                            label: 'confidenceHigh',
                            data: processed.confidenceHigh,
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderColor: 'rgba(255, 206, 86, 0.3)',
                            borderWidth: 1,
                            borderDash: [3, 3],
                            pointRadius: 0,
                            fill: '-1',
                            spanGaps: true,
                            order: 3
                        });

                        // Forecast line (dashed)
                        datasets.push({
                            label: '{{ _("Forecast") }}',
                            data: processed.forecastValues,
                            backgroundColor: 'rgba(255, 159, 64, 0.2)',
                            borderColor: 'rgba(255, 159, 64, 1)',
                            borderWidth: 2,
                            borderDash: [10, 5],
                            pointRadius: function(context) {
                                const index = context.dataIndex;
                                const value = context.dataset.data[index];
                                
                                // Hide null points
                                if (value === null) return 0;
                                
                                // Hide the connection point (where historical also has a value)
                                if (processed.historicalValues[index] !== null) {
                                    return 0;
                                }
                                
                                return 4;
                            },
                            pointHoverRadius: function(context) {
                                const index = context.dataIndex;
                                const value = context.dataset.data[index];
                                
                                if (value === null) return 0;
                                
                                if (processed.historicalValues[index] !== null) {
                                    return 0;
                                }
                                
                                return 6;
                            },
                            pointBackgroundColor: 'rgba(255, 159, 64, 1)',
                            spanGaps: true,
                            order: 1
                        });
                    }

                    // Update chart
                    chart.data.labels = processed.labels;
                    chart.data.datasets = datasets;
                    chart.update();

                    $("#chartSpinner").hide();
                })
                .catch(error => {
                    console.error("Fetch Error:", error);
                    $("#chartSpinner").hide();
                });
        }

        // Initialize page
        fetchChannels();
        $('#channelSelect').on("change", fetchData);

        // Initialize Bootstrap tooltips
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function(tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // Download chart as PNG with title
        $('#downloadPNG').on('click', function() {
            const chartTitle = "Monthly Streaming Hours - " + $('#channelSelect').val() + " - holochatstats.info";
            const backgroundColor = getComputedStyle(document.body).backgroundColor || '#1a1a1a';
            
            const originalCanvas = document.getElementById('streamingChart');
            
            const newCanvas = document.createElement('canvas');
            const titleHeight = 60;
            
            newCanvas.width = originalCanvas.width;
            newCanvas.height = originalCanvas.height + titleHeight;
            
            const newCtx = newCanvas.getContext('2d');
            
            newCtx.fillStyle = backgroundColor;
            newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
            
            newCtx.fillStyle = 'white';
            newCtx.font = 'bold 24px Arial';
            newCtx.textAlign = 'center';
            newCtx.fillText(chartTitle, newCanvas.width / 2, titleHeight / 2 + 10);
            
            newCtx.drawImage(originalCanvas, 0, titleHeight);
            
            const link = document.createElement('a');
            link.download = 'monthly_streaming_hours.png';
            link.href = newCanvas.toDataURL('image/png');
            link.click();
        });
    });
</script>
<script>
// Define the context for this specific page
window.EriWidgetContext.getContext = function() {
    // Get current page data
    const channel = $('#channelSelect').val();
    
    return {
        page: 'monthly_streaming_hours',
        endpoint: '/api/get_monthly_streaming_hours',
        parameters: {
            channel: channel
        },
        description: `Viewing monthly streaming hours for ${channel}`
    };
};
</script>
</body>
</html>
