<!DOCTYPE html>
<html lang="{{ get_locale() }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Live Chat Viewer - Watch YouTube videos with live chat and statistics">
    <title>Live Chat Viewer - HoloChatStats</title>
    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
    
    <style>
        body {
            background-color: #1a1a1a;
            color: white;
            overflow-x: hidden;
        }

        .url-input-section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 80px 20px 40px 20px;
        }

        .url-input-container {
            background-color: #2c3e50;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            width: 100%;
            max-width: 900px;
        }

        .url-input-group {
            max-width: 800px;
            margin: 0 auto;
        }

        .userscript-info {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(52, 152, 219, 0.2);
            border: 1px solid rgba(52, 152, 219, 0.5);
            border-radius: 8px;
            color: #fff;
        }

        .userscript-info a {
            color: #74c0fc;
            text-decoration: none;
            font-weight: 500;
        }

        .userscript-info a:hover {
            color: #a5d8ff;
            text-decoration: underline;
        }

        .userscript-info .bi {
            font-size: 1.1rem;
            vertical-align: middle;
        }

        .userscript-info small {
            color: #bbb !important;
        }

        .error-message {
            background-color: #dc3545;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }

        .success-message {
            background-color: #28a745;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }

        #videoSection {
            height: 100vh;
            display: none;
            position: relative;
            overflow: hidden;
        }

        .video-chat-container {
            display: flex;
            height: 100vh;
            width: 100%;
        }

        .left-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            height: 100vh;
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%;
            background-color: #000;
            flex-shrink: 0;
        }

        .video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        .stats-area {
            flex: 1;
            background-color: #1a1a1a;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            overflow: hidden;
        }

        .stats-container {
            display: flex;
            gap: 15px;
            width: 100%;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
        }

        .stat-box {
            background-color: #2c3e50;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
            min-width: 0;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 3px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-percentage {
            font-size: 0.8rem;
            color: #888;
        }

        .chat-wrapper {
            width: 400px;
            height: 100vh;
            background-color: #2a2a2a;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .chat-wrapper iframe {
            width: 100%;
            height: 100%;
            border: none;
            flex: 1;
        }

        .connection-indicator {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            z-index: 1000;
            display: none;
            transition: opacity 0.3s ease;
        }

        .connection-indicator.connected {
            background-color: #28a745;
            display: block;
        }

        .connection-indicator.disconnected {
            background-color: #dc3545;
            display: block;
        }

        .connection-indicator.fade-out {
            opacity: 0;
        }

        .stat-box-with-graph {
            position: relative;
            overflow: hidden;
        }

        .stat-graph {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.4;
        }

        .stat-content {
            position: relative;
            z-index: 1;
        }

        .ccv-trend {
            display: inline-block;
            margin-left: 4px;
            font-size: 0.9em;
        }

        .ccv-trend.up {
            color: #28a745;
        }

        .ccv-trend.down {
            color: #dc3545;
        }

        .ccv-trend.stable {
            color: #888;
        }

        @media (max-width: 1600px) {
            .ccv-trend {
                font-size: 0.85em;
            }
        }

        @media (max-width: 992px) {
            .ccv-trend {
                font-size: 0.75em;
            }
        }

        @media (max-width: 1600px) {
            .stat-value {
                font-size: 1.1rem;
            }
            .stat-label {
                font-size: 0.65rem;
            }
            .stat-box {
                padding: 6px 10px;
            }
        }

        @media (max-width: 1400px) {
            .stat-value {
                font-size: 1rem;
            }
            .stats-container {
                gap: 10px;
            }
        }

        @media (max-width: 1200px) {
            .chat-wrapper {
                width: 350px;
            }
            .stat-value {
                font-size: 0.9rem;
            }
            .stat-box {
                padding: 5px 8px;
            }
        }

        @media (max-width: 992px) {
            .video-chat-container {
                flex-direction: column;
                height: 100vh;
            }
            
            .left-section {
                flex: 0 0 65vh;
                height: 65vh;
            }
            
            .chat-wrapper {
                width: 100%;
                flex: 1;
                height: 35vh;
                min-height: 0;
            }
            
            .stats-area {
                padding: 8px;
            }
            
            .stats-container {
                gap: 5px;
                overflow-x: auto;
                overflow-y: hidden;
                padding-bottom: 5px;
            }
            
            .stat-box {
                padding: 4px 6px;
                flex: 0 0 auto;
                min-width: 80px;
            }
            
            .stat-value {
                font-size: 0.85rem;
            }
            
            .stat-label {
                font-size: 0.6rem;
            }
        }

        @media (max-width: 576px) {
            .stat-value {
                font-size: 0.8rem;
            }
            .stat-box {
                min-width: 70px;
            }
        }
    </style>
</head>
<body>

{% include 'menu.html' %}

<div class="connection-indicator" id="connectionIndicator">
    <i class="bi bi-circle-fill"></i> <span id="connectionText">Userscript Disconnected</span>
</div>

<div class="url-input-section">
    <div class="url-input-container">
        <h2 class="mb-4">{{ _("Live Chat Viewer") }}</h2>
        <p class="mb-4">{{ _("Enter a YouTube live stream URL to view the video with chat and statistics. VODs are not supported and the HyperChat browser extension must be disabled before using this feature.") }}</p>
        
        <div class="url-input-group">
            <div class="input-group">
                <input type="text" 
                       id="youtubeUrl" 
                       class="form-control form-control-lg" 
                       placeholder="https://www.youtube.com/watch?v=..." 
                       value="">
                <button class="btn btn-primary btn-lg" id="loadVideo">
                    <i class="bi bi-play-circle"></i> {{ _("Load") }}
                </button>
            </div>
        </div>

        <div class="userscript-info">
            <i class="bi bi-download"></i>
            <strong>{{ _("For live chat statistics:") }}</strong> 
            <a href="https://greasyfork.org/en/scripts/558153-holochatstats-live-chat-tracker" target="_blank">{{ _("Install the Userscript") }}</a>
            <small class="d-block mt-2">
                {{ _("Requires Greasemonkey (Firefox) or Tampermonkey (Chrome/Edge)") }}
            </small>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        <div class="success-message" id="successMessage">
            <i class="bi bi-check-circle"></i> {{ _("Video loaded! Chat statistics will appear if the userscript is installed.") }}
        </div>
    </div>
</div>

<div id="videoSection">
    <div class="video-chat-container">
        <div class="left-section">
            <div class="video-wrapper">
                <iframe id="videoFrame" 
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                        allowfullscreen>
                </iframe>
            </div>
            
            <div class="stats-area">
                <div class="stats-container">
                    <div class="stat-box">
                        <div class="stat-label">{{ _("Messages") }}</div>
                        <div class="stat-value" id="messageCount">0</div>
                    </div>
                    
                    <div class="stat-box stat-box-with-graph">
                        <canvas id="msgPerMinGraph" class="stat-graph"></canvas>
                        <div class="stat-content">
                            <div class="stat-label">{{ _("Msgs/Min") }}</div>
                            <div class="stat-value" id="messagesPerMinute">0</div>
                        </div>
                    </div>
                    
                    <div class="stat-box">
                        <div class="stat-label">{{ _("Users") }}</div>
                        <div class="stat-value" id="uniqueUsers">0</div>
                    </div>
                    
                    <div class="stat-box">
                        <div class="stat-label">{{ _("Members") }}</div>
                        <div class="stat-value">
                            <span id="memberCount">0</span>
                            <div class="stat-percentage" id="memberPercentage">(0%)</div>
                        </div>
                    </div>
                    
                    <div class="stat-box">
                        <div class="stat-label">{{ _("JP Messages") }}</div>
                        <div class="stat-value">
                            <span id="jpCount">0</span>
                            <div class="stat-percentage" id="jpPercentage">(0%)</div>
                        </div>
                    </div>
                    
                    <div class="stat-box">
                        <div class="stat-label">{{ _("Gifts / Purchases") }}</div>
                        <div class="stat-value">
                            <span id="giftCount">0</span> / <span id="purchaseCount">0</span>
                        </div>
                    </div>
                    
                    <div class="stat-box">
                        <div class="stat-label">{{ _("Est. Revenue") }}</div>
                        <div class="stat-value" id="estimatedRevenue">{{ "¥0" if get_locale() == "ja" else "$0" }}</div>
                    </div>
                    
                    <div class="stat-box stat-box-with-graph">
                        <canvas id="ccvGraph" class="stat-graph"></canvas>
                        <div class="stat-content">
                            <div class="stat-label">{{ _("CCV") }}</div>
                            <div class="stat-value">
                                <span id="ccvCount">-</span>
                                <span id="ccvTrend" class="ccv-trend"></span>
                            </div>
                        </div>
                    </div>

                    <div class="stat-box">
                        <div class="stat-label">{{ _("Time") }}</div>
                        <div class="stat-value" id="elapsedTime">0:00</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chat-wrapper">
            <iframe id="chatFrame"></iframe>
        </div>
    </div>
</div>

<script>
$(document).ready(function() {
    const currentLocale = '{{ get_locale() }}';
    const useJPY = currentLocale === 'ja';
    const USD_TO_JPY = 150; // Approximate conversion rate
    const MEMBERSHIP_PRICE_USD = 4.99;
    const MEMBERSHIP_PRICE_JPY = 750; // Approximate JPY price for membership
    
    let messageCount = 0;
    let textMessageCount = 0;
    let messageTimestamps = [];
    let startTime = null;
    let uniqueUsers = new Set();
    let memberUsers = new Set();
    let jpMessageCount = 0;
    let giftCount = 0;
    let purchaseCount = 0;
    // Store revenue in the base currency depending on locale
    let revenueBase = 0; // USD if not Japanese locale, JPY if Japanese locale
    let superChatCount = 0; // Track SuperChats separately for debugging
    let superStickerCount = 0; // Track SuperStickers separately
    let statsInterval = null;
    let currentVideoId = null;
    let connectionTimeout = null;
    let initialLoadComplete = false;
    let initialLoadTimeout = null;
    let ccvHistory = [];
    let ccvFetchInterval = null;
    let lastCCV = null;
    let msgPerMinHistory = [];
    const MAX_GRAPH_POINTS = 200; // Keep last 200 data points

    // Currency conversion rates to USD (used when locale is NOT Japanese)
    const currencyRatesToUSD = {
        '$': 1,
        '¥': 0.0067,
        '￥': 0.0067,
        '€': 1.09,
        '£': 1.27,
        '₩': 0.00075,
        'CA$': 0.74,
        'A$': 0.65,
        '₹': 0.012,
        'R$': 0.20,
        '₱': 0.018,
        'NT$': 0.031,
        'HK$': 0.13,
        'MX$': 0.059,
    };

    // Currency conversion rates to JPY (used when locale IS Japanese)
    const currencyRatesToJPY = {
        '$': 150,
        '¥': 1,
        '￥': 1,
        '€': 163,
        '£': 190,
        '₩': 0.11,
        'CA$': 111,
        'A$': 97,
        '₹': 1.8,
        'R$': 30,
        '₱': 2.7,
        'NT$': 4.7,
        'HK$': 19,
        'MX$': 8.8,
    };

    function hasJapanese(text) {
        const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u3400-\u4DBF]/;
        return japaneseRegex.test(text);
    }

    function isWOnlyMessage(text) {
        if (!text) return false;
        const cleaned = text.replace(/\s/g, '');
        return cleaned.length > 0 && /^[wWｗ]+$/.test(cleaned);
    }

    function hasActualText(text) {
        if (!text) return false;
        if (isWOnlyMessage(text)) return true;
        
        const withoutEmoji = text
            .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '')
            .replace(/[\u2600-\u27BF]/g, '')
            .replace(/[\u2300-\u23FF]/g, '')
            .replace(/[\u2B50\u2B55]/g, '')
            .replace(/[\u3030\u303D\u3297\u3299]/g, '')
            .replace(/[\u200D\uFE0F\uFE0E]/g, '')
            .replace(/[\u0023\u002A\u0030-\u0039]\uFE0F?\u20E3/g, '')
            .replace(/[\uD83C][\uDDE6-\uDDFF]/g, '');
        
        const withoutYtEmotes = withoutEmoji.replace(/:[a-zA-Z0-9_-]+:/g, '');
        
        return withoutYtEmotes.trim().length > 0;
    }

    function isJapaneseMessage(text) {
        if (!text) return false;
        if (isWOnlyMessage(text)) return true;
        return hasJapanese(text);
    }

    function parseSuperChatAmount(amountString) {
        if (!amountString) return 0;
        
        const cleaned = amountString.replace(/[\s,]/g, '');
        const rates = useJPY ? currencyRatesToJPY : currencyRatesToUSD;
        
        // Check for currency symbols in order of specificity (longer symbols first)
        const sortedSymbols = Object.keys(rates).sort((a, b) => b.length - a.length);
        
        for (const symbol of sortedSymbols) {
            if (cleaned.includes(symbol)) {
                const amount = parseFloat(cleaned.replace(symbol, '').replace(/[^\d.]/g, ''));
                if (!isNaN(amount)) {
                    return amount * rates[symbol];
                }
            }
        }
        
        // Fallback: try to parse as number (assume base currency)
        const amount = parseFloat(cleaned.replace(/[^\d.]/g, ''));
        return isNaN(amount) ? 0 : amount;
    }

    function formatRevenue(amountBase) {
        if (useJPY) {
            const amountJPY = Math.round(amountBase);
            return '¥' + amountJPY.toLocaleString();
        } else {
            return '$' + amountBase.toFixed(2);
        }
    }

    function getMembershipPrice() {
        return useJPY ? MEMBERSHIP_PRICE_JPY : MEMBERSHIP_PRICE_USD;
    }

    function updateRevenueDisplay() {
        $('#estimatedRevenue').text(formatRevenue(revenueBase));
    }

    window.addEventListener('message', function(event) {
        if (event.origin !== 'https://www.youtube.com') return;
        
        const data = event.data;
        if (data.type === 'HOLOCHATSTATS_CHAT_MESSAGE') {
            handleChatMessage(data.payload);
        } else if (data.type === 'HOLOCHATSTATS_SCRIPT_READY') {
            updateConnectionStatus(true);
            console.log('Userscript connected successfully!');
        } else if (data.type === 'HOLOCHATSTATS_CCV_UPDATE') {
            updateCCV(data.ccv);
        }
    });

    function updateConnectionStatus(connected) {
        const indicator = $('#connectionIndicator');
        const text = $('#connectionText');
        
        if (connectionTimeout) {
            clearTimeout(connectionTimeout);
            connectionTimeout = null;
        }
        
        if (connected) {
            indicator.removeClass('disconnected fade-out').addClass('connected');
            text.text('Userscript Connected');
            
            connectionTimeout = setTimeout(() => {
                indicator.addClass('fade-out');
                setTimeout(() => {
                    indicator.removeClass('connected').hide();
                }, 300);
            }, 3000);
        } else {
            indicator.removeClass('connected fade-out').addClass('disconnected').show();
            text.text('Userscript Disconnected');
        }
    }

    function handleChatMessage(message) {
        if (!startTime) startTime = Date.now();
        
        messageCount++;
        $('#messageCount').text(messageCount.toLocaleString());
        
        if (initialLoadComplete) {
            messageTimestamps.push(Date.now());
            const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
            messageTimestamps = messageTimestamps.filter(ts => ts > fiveMinutesAgo);
        }
        
        if (message.author) {
            uniqueUsers.add(message.author);
            $('#uniqueUsers').text(uniqueUsers.size.toLocaleString());
            
            if (message.isMember || (message.badges && message.badges.some(badge => 
                badge && (badge.toLowerCase().includes('member') || 
                          badge.toLowerCase().includes('sponsor'))))) {
                memberUsers.add(message.author);
            }
        }
        
        const messageHasText = hasActualText(message.message);
        if (messageHasText) {
            textMessageCount++;
            
            if (isJapaneseMessage(message.message)) {
                jpMessageCount++;
            }
        }
        
        // Track membership gift redemptions (someone received a gifted membership)
        if (message.isMembershipGiftRedemption) {
            giftCount++;
            $('#giftCount').text(giftCount.toLocaleString());
            revenueBase += getMembershipPrice();
            updateRevenueDisplay();
        }
        
        // Track membership purchases (new member or membership milestone)
        // Note: This should NOT include SuperChats or SuperStickers
        if (message.isMembershipPurchase && !message.isSuperChat && !message.isSuperSticker) {
            purchaseCount++;
            $('#purchaseCount').text(purchaseCount.toLocaleString());
            revenueBase += getMembershipPrice();
            updateRevenueDisplay();
        }
        
        // Track SuperChat and SuperSticker earnings
        if (message.isSuperChat && message.superChatAmount) {
            const amount = parseSuperChatAmount(message.superChatAmount);
            if (amount > 0) {
                revenueBase += amount;
                updateRevenueDisplay();
                
                // Track counts for debugging
                if (message.isSuperSticker) {
                    superStickerCount++;
                    console.log('SuperSticker:', message.superChatAmount, '-> Base:', amount);
                } else {
                    superChatCount++;
                    console.log('SuperChat:', message.superChatAmount, '-> Base:', amount);
                }
            }
        }
        
        updatePercentages();
    }

    function updatePercentages() {
        if (uniqueUsers.size > 0) {
            const memberPercentage = ((memberUsers.size / uniqueUsers.size) * 100).toFixed(1);
            $('#memberCount').text(memberUsers.size.toLocaleString());
            $('#memberPercentage').text(`(${memberPercentage}%)`);
        }
        
        if (textMessageCount > 0) {
            const jpPercentage = ((jpMessageCount / textMessageCount) * 100).toFixed(1);
            $('#jpCount').text(jpMessageCount.toLocaleString());
            $('#jpPercentage').text(`(${jpPercentage}%)`);
        } else {
            $('#jpCount').text(jpMessageCount.toLocaleString());
            $('#jpPercentage').text('(0%)');
        }
    }
    function extractVideoId(url) {
        const patterns = [
            /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
            /youtube\.com\/v\/([^&\n?#]+)/,
            /youtube\.com\/live\/([^&\n?#]+)/
        ];
        
        for (let pattern of patterns) {
            const match = url.match(pattern);
            if (match) return match[1];
        }
        return null;
    }

    function showError(message) {
        $('#errorMessage').text(message).show();
        setTimeout(() => $('#errorMessage').fadeOut(), 5000);
    }

    function updateStats() {
        if (startTime) {
            const elapsed = Date.now() - startTime;
            const elapsedMinutes = Math.floor(elapsed / 60000);
            const elapsedSeconds = Math.floor((elapsed % 60000) / 1000);
            $('#elapsedTime').text(`${elapsedMinutes}:${elapsedSeconds.toString().padStart(2, '0')}`);
        }
        
        let currentMsgPerMin = 0;
        
        if (initialLoadComplete && messageTimestamps.length > 0) {
            const now = Date.now();
            const fiveMinutesAgo = now - (5 * 60 * 1000);
            const recentMessages = messageTimestamps.filter(ts => ts > fiveMinutesAgo);
            
            if (recentMessages.length > 0) {
                const timeSpan = Math.min(now - messageTimestamps[0], 5 * 60 * 1000) / 60000;
                currentMsgPerMin = timeSpan > 0 ? parseFloat((recentMessages.length / timeSpan).toFixed(1)) : 0;
                $('#messagesPerMinute').text(currentMsgPerMin);
            } else {
                $('#messagesPerMinute').text('0');
            }
        } else {
            $('#messagesPerMinute').text('0');
        }
        
        // Update message per minute history (every 5 seconds to avoid too frequent updates)
        const now = Date.now();
        const lastEntry = msgPerMinHistory[msgPerMinHistory.length - 1];
        
        if (!lastEntry || (now - lastEntry.timestamp) >= 5000) {
            msgPerMinHistory.push({
                value: currentMsgPerMin,
                timestamp: now
            });
            
            // Keep only last MAX_GRAPH_POINTS data points
            if (msgPerMinHistory.length > MAX_GRAPH_POINTS) {
                msgPerMinHistory = msgPerMinHistory.slice(-MAX_GRAPH_POINTS);
            }
            
            // Update the graph
            updateMsgPerMinGraph();
        }
    }

    function fetchCCV() {
        if (!currentVideoId) return;
        
        // Method 1: Try to get from the chat iframe's parent page via our API endpoint
        fetch(`/api/ccv/${currentVideoId}`)
            .then(response => {
                if (response.ok) {
                    return response.json();
                }
                throw new Error('API not available');
            })
            .then(data => {
                if (data.ccv !== null && data.ccv !== undefined) {
                    updateCCV(data.ccv);
                }
            })
            .catch(error => {
                // Method 2: Try to extract from YouTube's oembed endpoint (limited info)
                // This is a fallback but may not always have live viewer count
                console.log('CCV fetch error, trying fallback:', error);
                fetchCCVFallback();
            });
    }

    function fetchCCVFallback() {
        // Fallback: Request CCV from userscript
        const chatFrame = document.getElementById('chatFrame');
        if (chatFrame && chatFrame.contentWindow) {
            chatFrame.contentWindow.postMessage({
                type: 'HOLOCHATSTATS_REQUEST_CCV'
            }, 'https://www.youtube.com');
        }
    }

    function updateCCV(count) {
        if (count === null || count === undefined || isNaN(count)) {
            $('#ccvCount').text('-');
            $('#ccvTrend').removeClass('up down stable').text('');
            return;
        }
        
        const ccv = parseInt(count);
        
        // Update display
        $('#ccvCount').text(ccv.toLocaleString());
        
        // Determine trend
        const trendEl = $('#ccvTrend');
        trendEl.removeClass('up down stable');
        
        if (lastCCV !== null) {
            const diff = ccv - lastCCV;
            const threshold = Math.max(10, lastCCV * 0.01); // 1% or at least 10 viewers
            
            if (diff > threshold) {
                trendEl.addClass('up').html('<i class="bi bi-arrow-up"></i>');
            } else if (diff < -threshold) {
                trendEl.addClass('down').html('<i class="bi bi-arrow-down"></i>');
            } else {
                trendEl.addClass('stable').html('<i class="bi bi-dash"></i>');
            }
        } else {
            trendEl.addClass('stable').html('<i class="bi bi-dash"></i>');
        }
        
        // Store history
        ccvHistory.push({
            count: ccv,
            timestamp: Date.now()
        });
        
        // Keep only last MAX_GRAPH_POINTS data points
        if (ccvHistory.length > MAX_GRAPH_POINTS) {
            ccvHistory = ccvHistory.slice(-MAX_GRAPH_POINTS);
        }
        
        lastCCV = ccv;
        
        // Update the graph
        updateCCVGraph();
    }

    function loadVideoAndChat() {
        const url = $('#youtubeUrl').val().trim();
        if (!url) {
            showError('{{ _("Please enter a YouTube URL") }}');
            return;
        }

        const videoId = extractVideoId(url);
        if (!videoId) {
            showError('{{ _("Invalid YouTube URL") }}');
            return;
        }

        currentVideoId = videoId;

        // Reset all statistics
        messageCount = 0;
        textMessageCount = 0;
        messageTimestamps = [];
        jpMessageCount = 0;
        giftCount = 0;
        purchaseCount = 0;
        revenueBase = 0;
        superChatCount = 0;
        superStickerCount = 0;
        uniqueUsers.clear();
        memberUsers.clear();
        startTime = null;
        initialLoadComplete = false;
        
        // Reset CCV and graph histories
        ccvHistory = [];
        lastCCV = null;
        msgPerMinHistory = [];
        
        // Reset displays
        $('#messageCount').text('0');
        $('#messagesPerMinute').text('0');
        $('#elapsedTime').text('0:00');
        $('#uniqueUsers').text('0');
        $('#memberCount').text('0');
        $('#memberPercentage').text('(0%)');
        $('#jpCount').text('0');
        $('#jpPercentage').text('(0%)');
        $('#giftCount').text('0');
        $('#purchaseCount').text('0');
        $('#ccvCount').text('-');
        $('#ccvTrend').removeClass('up down stable').text('');
        updateRevenueDisplay();
        updateConnectionStatus(false);
        
        // Clear graphs
        const ccvCanvas = document.getElementById('ccvGraph');
        const msgCanvas = document.getElementById('msgPerMinGraph');
        if (ccvCanvas) {
            const ctx = ccvCanvas.getContext('2d');
            ctx.clearRect(0, 0, ccvCanvas.width, ccvCanvas.height);
        }
        if (msgCanvas) {
            const ctx = msgCanvas.getContext('2d');
            ctx.clearRect(0, 0, msgCanvas.width, msgCanvas.height);
        }

        if (statsInterval) clearInterval(statsInterval);
        if (initialLoadTimeout) clearTimeout(initialLoadTimeout);
        if (ccvFetchInterval) clearInterval(ccvFetchInterval);

        // Set up video iframe
        $('#videoFrame').attr('src', `https://www.youtube.com/embed/${videoId}?autoplay=1`);
        
        // Set up chat iframe
        const chatUrl = `https://www.youtube.com/live_chat?v=${videoId}&embed_domain=${window.location.hostname}&dark_theme=1`;
        $('#chatFrame').attr('src', chatUrl);
        
        // Show video section
        $('#videoSection').fadeIn();
        $('#successMessage').show();
        setTimeout(() => $('#successMessage').fadeOut(), 5000);
        
        $('html, body').animate({
            scrollTop: $('#videoSection').offset().top
        }, 500);

        // Start updating stats
        statsInterval = setInterval(updateStats, 1000);

        // Start fetching CCV every 2 minutes
        setTimeout(fetchCCV, 3000); // Initial fetch after 3 seconds
        ccvFetchInterval = setInterval(fetchCCV, 120000);

        initialLoadTimeout = setTimeout(() => {
            initialLoadComplete = true;
            console.log('Initial load period complete, now tracking message rate');
        }, 5000);

        // Send video ID to userscript
        setTimeout(() => {
            const chatFrame = document.getElementById('chatFrame');
            if (chatFrame && chatFrame.contentWindow) {
                chatFrame.contentWindow.postMessage({
                    type: 'HOLOCHATSTATS_VIDEO_LOADED',
                    videoId: videoId
                }, 'https://www.youtube.com');
            }
        }, 2000);
    }

    function drawGraph(canvasId, dataPoints, color) {
        const canvas = document.getElementById(canvasId);
        if (!canvas || dataPoints.length < 2) return;
        
        const ctx = canvas.getContext('2d');
        const rect = canvas.parentElement.getBoundingClientRect();
        
        // Set canvas size to match container (with device pixel ratio for sharpness)
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        // Clear canvas
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        // Get min/max values for scaling
        const values = dataPoints.map(p => p.value);
        let minVal = Math.min(...values);
        let maxVal = Math.max(...values);
        
        // Add padding to min/max to prevent line from touching edges
        const range = maxVal - minVal;
        if (range === 0) {
            minVal = minVal * 0.9;
            maxVal = maxVal * 1.1 || 1;
        } else {
            minVal = minVal - range * 0.1;
            maxVal = maxVal + range * 0.1;
        }
        
        const padding = { top: 8, bottom: 8, left: 4, right: 4 };
        const graphWidth = rect.width - padding.left - padding.right;
        const graphHeight = rect.height - padding.top - padding.bottom;
        
        // Calculate points
        const points = dataPoints.map((point, index) => {
            const x = padding.left + (index / (dataPoints.length - 1)) * graphWidth;
            const y = padding.top + graphHeight - ((point.value - minVal) / (maxVal - minVal)) * graphHeight;
            return { x, y };
        });
        
        // Draw gradient fill under the line
        const gradient = ctx.createLinearGradient(0, padding.top, 0, rect.height - padding.bottom);
        gradient.addColorStop(0, color.replace(')', ', 0.3)').replace('rgb', 'rgba'));
        gradient.addColorStop(1, color.replace(')', ', 0.05)').replace('rgb', 'rgba'));
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, rect.height - padding.bottom);
        points.forEach(point => ctx.lineTo(point.x, point.y));
        ctx.lineTo(points[points.length - 1].x, rect.height - padding.bottom);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw the line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        // Use smooth curves
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const midX = (prev.x + curr.x) / 2;
            ctx.quadraticCurveTo(prev.x, prev.y, midX, (prev.y + curr.y) / 2);
        }
        ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
    }

    function updateCCVGraph() {
        // Use a muted teal/cyan color for CCV
        drawGraph('ccvGraph', ccvHistory.map(h => ({ value: h.count })), 'rgb(72, 166, 167)');
    }

    function updateMsgPerMinGraph() {
        // Use a muted blue color for messages per minute
        drawGraph('msgPerMinGraph', msgPerMinHistory.map(h => ({ value: h.value })), 'rgb(92, 144, 210)');
    }

    // Handle window resize to redraw graphs
    let resizeTimeout;
    $(window).on('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            updateCCVGraph();
            updateMsgPerMinGraph();
        }, 100);
    });

    // Event listeners
    $('#loadVideo').click(loadVideoAndChat);
    
    $('#youtubeUrl').keypress(function(e) {
        if (e.which === 13) {
            loadVideoAndChat();
        }
    });

    // Clean up on page unload
    $(window).on('beforeunload', function() {
        if (statsInterval) clearInterval(statsInterval);
        if (connectionTimeout) clearTimeout(connectionTimeout);
        if (initialLoadTimeout) clearTimeout(initialLoadTimeout);
        if (ccvFetchInterval) clearInterval(ccvFetchInterval);
    });
});
</script>

</body>
</html>